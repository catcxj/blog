# 什么是设计模式？
“设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。

设计模式是对软件设计开发过程中反复出现的某类问题的通用解决方案。

设计模式更多的是指导思想和方法论，而不是现成的代码，当然每种设计模式都有每种语言中的具体实现方式。

狭义的，常见的设计模式有 23 种经典设计模式。

# 设计模式的类型
设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。

## 1. 根据目的来分
根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。
- **创建型模式**：处理对象的创建，完成“将对象的创建与使用分离”。
  
- **结构型模式**：处理对象间的逻辑和关系，完成简化系统的设计。
  
- **行为型模式**：处理多个对象之间的交互，共同完成单个对象都无法单独完成的任务。

## 2. 根据作用范围来分
根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。

在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。class 的本质依然还是 function。
 
它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。

本次讲解暂时不以类和对象的区别展开。

## 3. 23 种设计模式的分类表

| 创建型模式 | 结构型模式 | 行为型模式 |
| --------  | --------  | --------  |
| 单例<br>原型<br>抽象工厂<br>建造者<br>工厂方法 | 代理<br>适配器<br>桥接<br>装饰<br>外观<br>享元<br>组合 | 策略<br>命令<br>观察者<br>中介者<br>迭代器<br>访问者<br>备忘录<br>职责链<br>状态<br>模板方法<br>解释器 |

<br>

# 前端常用到的几个设计模式
创建型模式
## 1. 工厂模式（Factory Pattern）
非常接近高阶组件hoc（High Order Component），根据传入工程对象参数不同制作出不同对象的方法。工厂模式提供一种集中化、统一化的方式，避免了分散创建对象导致的代码重复、灵活性差的问题。

// 有待加强

## 2. 单例模式（Singleton Pattern）
顾名思义，单例模式中Class的实例个数最多为1。更常见的就是声明变量，每个变量都是一个单例，但不绝对，受到生命周期的限制。

使用过程中需要避免多次实例化。

---
结构型模式
## 1. 外观模式（Facade Pattern）
我们常用的框架和库基本都遵循了外观设计模式，比如JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。
```javascript
// 兼容性事件绑定函数
function addEvent(element, event, handler) {
  if (element.addEventListener) {
    element.addEventListener(event, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent('on' + event, handler);
  } else {
    element['on' + event] = fn;
  }
}
```

## 2. 代理模式（Proxy Pattern）
代理就是帮你处理你无法完成的事务，ES6中增加了 Proxy 的功能。

// 有待加强

---
行为型模式
## 1. 策略模式（Strategy Pattern）
策略模式简单描述就是：对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。

最常见的使用策略模式的场景如登录鉴权，鉴权算法取决于用户的登录方式是手机、邮箱或者第三方的微信登录等等，而且登录方式也只有在运行时才能获取，获取到登录方式后再动态的配置鉴权策略。
```javascript
/**
 * 登录控制器
 */
function LoginController() {
  this.strategy = undefined;
  this.setStrategy = function (strategy) {
    this.strategy = strategy;
    this.login = this.strategy.login;
  }
}

/**
 * 用户名、密码登录策略
 */
function LocalStragegy() {
  this.login = ({ username, password }) => {
    // authenticating with username and password... 
  }
}

/**
 * 手机号、验证码登录策略
 */
function PhoneStragety() {
  this.login = ({ phone, verifyCode }) => {
    // authenticating with hone and verifyCode... 
  }
}

/**
 * 第三方社交登录策略
 */
function SocialStragety() {
  this.login = ({ id, secret }) => {
    // authenticating with id and secret... 
  }
}

const loginController = new LoginController();

// 调用用户名、密码登录接口，使用LocalStrategy
app.use('/login/local', function (req, res) {
  loginController.setStrategy(new LocalStragegy());
  loginController.login(req.body);
});

// 调用手机、验证码登录接口，使用PhoneStrategy
app.use('/login/phone', function (req, res) {
  loginController.setStrategy(new PhoneStragety());
  loginController.login(req.body);
});

// 调用社交登录接口，使用SocialStrategy
app.use('/login/social', function (req, res) {
  loginController.setStrategy(new SocialStragety());
  loginController.login(req.body);
});
```

## 2. 迭代器模式（Iterator Pattern）
迭代器用于遍历容器（集合）并访问容器中的元素，而且无论容器的数据结构是什么（Array、Set、Map等），迭代器的接口都应该是一样的，都需要遵循迭代器协议。

迭代器模式解决了以下问题：
1. 提供一致的遍历各种数据结构的方式，而不用了解数据的内部结构
2. 提供遍历容器（集合）的能力而无需改变容器的接口

## 3. 观察者模式（Observer Pattern）
观察者模式又称发布订阅模式（Publish/Subscribe Pattern），是我们经常接触到的设计模式。

被观察对象（subject）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。
最常见的就是动态绑定。
```javascript
target.addEventListener(type, listener [, options]);
```

## 4. 中介者模式（Mediator Pattern）
在中介者模式中，中介者（Mediator）包装了一系列对象相互作用的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。

中介者模式和观察者模式有一定的相似性，都是一对多的关系，也都是集中式通信，不同的是中介者模式是处理同级对象之间的交互，而观察者模式是处理Observer和Subject之间的交互。

常见的有redux或者是vuex。

## 5. 访问者模式（Visitor Pattern）
访问者模式常用于拓展一些第三方的库和工具。